昨天内容回忆
一、system(3)的使用
调用一个（内外）命令。或者脚本程序。
/bin/sh -c command

二、管道(无名  有名)
无名管道应用于具有亲缘关系的进程间通讯。
无名管道是单工的。

有名管道，就是借助与管道文件实现进程间的通讯。

三、文件输入重定向的实现。
四、信号的基础
信号的捕获。
信号的处理程序有三种：
1、SIG_DFL
2、SIG_IGN
3、用户自定义
验证了信号处理函数可以被子进程继承。

补充实验   system(3) 调用内部命令   见system.c

今天内容：
一、信号的产生
通过三种方式可以产生一个信号
1、快捷键  ctrl+c   ctrl+\
2、通过命令产生信号
kill  -信号编号  pid
3、通过使用函数产生信号
kill(2)
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
功能：给指定进程（组）发送指定信号
参数：
pid：指定进程(组)pid
sig：指定信号的编号
返回值：
0 成功
-1 失败 errno被设置

rasie(3)给自己发信号
#include <signal.h>
int raise(int sig);
功能：发送信号给当前进程
参数：
sig：指定信号的编号
返回值：
0  成功
非0 失败

举例说明  给进程发送信号。 代码参见  send_s.c
代码参见  mykill.c
mykill 信号编号 pid

闹钟信号
alarm(2)
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
功能：将信号SIGALRM递送给当前进程，在指定的seconds秒内。
参数：
seconds：设定了闹钟值,如果为0,取消上次闹钟。
返回值：
返回上次闹钟剩余的时间。

编写代码验证alarm（2）的使用   代码参见alarm.c.

二、信号的阻塞和未决信号
进程可以设置对某个信号进行阻塞。进程阻塞的信号就不能递达给进程，当进程
接除对信号的阻塞，信号才能递达。

信号未决  信号产生了，但是信号还没有被捕获到。
这段时间处于未决状态，称为未决信号。

sigset_t 类型  信号集
对信号集类型的操作有以下几种;
sigemptyset(3);

#include <signal.h>
int sigemptyset(sigset_t *set);
功能：初始化指定的信号集为空，所有的信号都清为0.
参数：
set:指定要初始化的信号集
返回值：
0  成功
-1 错误


int sigfillset(sigset_t *set);
功能：初始化指定的信号集为满。这个信号集里包含所有的信号。
参数：
set：指定要初始化的信号集
返回值：
0  成功
-1 错误


int sigaddset(sigset_t *set, int signum);
功能：将信号添加到信号集当中
参数：
set：指定信号集
signum：指定具体的信号，将这个信号添加到信号集中
返回值：
0  成功
-1 错误


int sigdelset(sigset_t *set, int signum);
功能：从指定的信号集中删除信号
参数：
set：指定信号集
signum：指定的要删除的信号
返回值：
0  成功
-1 错误


int sigismember(const sigset_t *set, int signum);
功能：测试信号是否是信号集的成员
参数：
set：指定信号集
signum：指定要测试的具体信号
返回值：
-1  错误
0   这个信号不是这个信号集里的一员
1   这个信号是这个信号集里的一员

需要使用sigset_t类型的变量，将这个变量设置为进程对信号的阻塞集合。

如何设置进程的信号屏蔽字（阻塞集合）。
sigprocmask(2)
#include <signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
功能：检测或者改变进程的阻塞信号集
参数：
how：
SIG_BLOCK：将set信号集和当前进程的阻塞信号集并集操作。
SIG_UNBLOCK：将set集合里的信号从当前进程的阻塞信号集中移除
SIG_SETMASK：将信号集set设置为进程的阻塞信号集。
set：用户指定的集合
oldset：存储了旧的信号阻塞集合
返回值：
0   成功
-1  错误

举例说明  设置进程对2号信号阻塞。代码参见  blocked.c

多次发送2、3号信号，但是在进程解除对信号的阻塞的时候。对这两个信号分别
做了一次信号处理。造成了信号的丢失。
这样的信号称为不可以靠的信号。1～31号信号

信号阻塞的时候，会将到达的信号放入队列中，在解除对信号的阻塞的时候，从
队列中取出，一个个处理，这种不会造成信号的丢失，这样的信号称为可靠信号
。34～64号信号，也称实时信号。  

如何检测进程的未决信号？
sigpending(2)
#include <signal.h>
int sigpending(sigset_t *set);
功能：检测进程的未决信号
参数：
set：用来存储进程的未决信号集
返回值：
0  成功
-1 错误
举例说明   检测进程的未决信号集
代码参见   pending.c


三、使用pause(2)暂停程序的执行

pause(2)
#include <unistd.h>
int pause(void);
功能：使进程进入睡眠状态，直到信号到达（信号处理函数执行完毕）。
参数：
void
返回值：
-1  错误  errno被设置
信号被捕获，并且信号处理函数返回以后才返回。

举例说明 pause(2)使用。
使用alarm(2)和pause(2)函数实现sleep的功能。
代码参见  mysleep.c

四、信号的处理过程。
1、在bash下启动一个进程
2、按下ctrl+c键，产生了硬件中断。
3、进程从用户态切换到内核态，处理这个中断。
4、系统的驱动程序将这个中断解释为2号信号。
5、将进程的PCB中的信号部分的信息对应的2号信号设置为1。
这时候代表信号的递达。
6、当进程从内核态切换到用户态的时候会检测进程的信号信息，如果说信号
对应的信息为1,代表信号已经递达，这时候调用信号的处理函数。
如果信号对应的信息为0，代表没有信号的到达，切换到用户态运行进程即可。

7、信号的处理函数执行完毕的时候，调用sigreturn(2)，从信号处理函数返回，
并清理栈帧。返回到内核态。
8、进程在内核态继续运行，当进程再次返回到用户态的时候，再次检测进程的信
号到达情况。返回到内核态第六步。

注意：信号的处理函数和进程是两个不同的执行流程，
这两个执行流程是异步的。
两个不同的执行路线有可能竞争同一个资源。
面临着竞争资源的问题。
在变成的时候尽量避免竞争的问题。
怎么避免竞争？
这两条执行路线是在同一个进程中的。
这两条执行路线共享进程的资源。
代码段    数据段  堆   栈段
(一个进程只有一个栈段，有多个栈帧， 只有一个栈帧对应一个函数)
每个函数都有自己的私有空间    这个私有空间就是栈帧
除了栈帧之外，其他的都属于进程中的所有执行路线的共享资源。

如果想确保这个函数安全，尽量的让这个函数使用栈帧里的东西。
如果函数中使用的所有变量的空间都分配在占帧里。----
----这样的函数称为可重入函数。

只要访问了代码段、数据段、堆里的空间都称为不可重入函数。
(库函数一般都是不可重入函数，尽量使用系统调用函数)

举例说明 可重入函数   代码参见  reentry.c

总结：
一、信号的产生
1、硬件产生
2、命令产生
3、函数产生
二、信号的阻塞和未决信号
sigset_t类型    信号集类型
sigprocmask(2)
sigpending(2)
三、pause(2)函数的使用
四、信号的处理过程
过程
可重入函数






